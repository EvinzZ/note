# 并发编程基础

## 1、三种创建方式

- 继承Thread类

  继承Thread类，重写run()方法，调用start开启线程。

  不建议使用：避免OOP单继承局限性

- 实现Runnable接口

  实现Runnable接口，实现run()方法，创建线程对象，调用start()方法启动线程。

  推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

- 实现Callable接口

注意：

> 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

## 2、线程方法

setPriority(int newPriority)

更改线程的优先级

static void sleep(long millis)

在指定的毫秒数内让当前正在执行的线程休眠

void join()

等待该线程终止

static void yield()

暂停当前正在执行的线程对象，并执行其他线程

void interrupt()

中断线程，别用这个方式

boolean isAlive()

测试线程是否处于活动状态

## 3、线程状态

### 3.1、java中线程状态

**Thread.State**

线程状态。线程可以处于以下状态之一：

- NEW

  尚未启动的线程处于此状态。

- RUNNABLE

  在Java虚拟机中执行的线程处于此状态。

- BLOCKED

  被阻塞等待监视器锁定的线程处于此状态。

- WAITING

  正在等待另一个线程执行特定动作的线程处于此状态。

- TIMEED_WAITING

  正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。

- TERMINATED

  已退出的线程处于此状态

示例图：

![image_10_sgfdswq](/Users/sin/Desktop/pro/note/images/image_10_sgfdswq.png)

JDK源码里的状态：

![image_11_afgteaw](/Users/sin/Desktop/pro/note/images/image_11_afgteaw.png)

### 3.2、操作系统层面有5种状态

操作系统层面有5种状态

1. 分到CPU时间的：运行
2. 可以分到CPU时间的：就绪
3. 分不到CPU时间的：阻塞

![image_12_trqwe](/Users/sin/Desktop/pro/note/images/image_12_trqwe.png)

## 4、线程优先级

java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级应该调度哪个线程来执行。

线程的优先级用数字表示，范围从1～10.

- Thread.MIN_PRIORITY = 1;
- Thread.MAX_PRIORITY = 10;
- Thread.NORM_PRIORITY = 5;

使用以下方式改变或获取优先级

- `getPriotity()`、`setPriority(int xxx)`

优先级的设定建议在start()调度前

优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度

## 5、守护线程

- 线程分为用户线程和守护线程
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕
- 如，后台记录操作日志，监控内存，垃圾回收等待。

## 6、线程同步

处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。

## 7、并发

同一个对象被多个线程同时操作

## 8、锁

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制`synchronized`，当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：

- 一个线程持有锁会导致其他所有需要此锁的线程挂起
- 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换 和 调度延时，引起性能问题
- 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题

### 8.1、同步方法

- 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized和synchronized块

```Java
同步方法：
public synchronized void method (int args) {}
```

- synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

> 缺陷：若将一个大的方法申明为synchronized将会影响效率。

### 8.2、同步块

同步块：synchronized (Obj) {}

Obj称之为同步监视器

- obj可以是任何对象，但是推荐使用共享资源作为同步监视器
- 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class

同步监视器的执行过程

1. 第一个线程访问，锁定同步监视器，执行其中代码
2. 第二个线程访问，发现同步监视器被锁定，无法访问
3. 第一个线程访问完毕，解锁同步监视器
4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

## 9、死锁

多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。

产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 10、Lock（锁）

java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁。

案例

```Java
class A {
  private final ReentrantLock lock = new ReentrantLock();
  public void m () {
    lock.lock();
    try {
      // 保证线程安全的代码
    } finally {
      lock.unlock();
      // 如果同步代码有异常，要将unlock()写入finally语句块
    }
  }
}
```

synchronized和Lock的对比

- Lock是显示锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
- Lock只有代码块锁，synchronized有代码块和方法锁
- 使用lock锁，jvm将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）
- 优先使用顺序：
  - Lock > 同步代码块 > 同步方法

### 10.1、lock和synchronized

语法层面

- `synchronized`是关键字，源码在JVM中，用C++实现
- Lock是接口，源码由jdk提供，用java语言实现
- 使用`synchronized`时，退出代码块会自动释放，而使用Lock时，需要手动调用`unlock`方法释放锁

功能层面

- 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能

- Lock提供了许多`synchronized`不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量

  > `synchronized`只支持非公平锁，不能被打断，没有超时时间

- Lock有适合不同场景的实现，如`ReentrantLock`，`ReentrantReadWriteLock`

性能层面

- 在没有竞争时，`synchronized`做了很多优化，如偏向锁、轻量级锁，性能不赖
- 在竞争激烈时，Lock的实现通常性能更好

## 11、线程协作

Java提供了几个方法解决线程之间的通信问题

| 方法名               | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| `wait()`             | 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁    |
| `wait(long timeout)` | 指定等待的毫秒数                                             |
| `notify()`           | 唤醒一个处于等待状态的线程                                   |
| `notifyAll()`        | 唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度 |

## 12、`wait()`和`sleep()`

共同点：`wait()`，`wait(long)`和`sleep(long)`的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态

方法归属不同

1. `sleep(long)`是Thread的静态方法
2. 而`wait()`，`wait(long)`都是Object的成员方法，每个对象都有

醒来时机不同

1. 执行`sleep(long)`和`wait(long)`的线程都会在等待相应毫秒后醒来
2. `wait(long)`和`wait()`还可以被`notify`唤醒，`wait()`如果不唤醒就一直等下去
3. 它们都可以被打断唤醒

锁特性不同

1. `wait`方法的调用必须先获取`wait`对象的锁，而`sleep`则无此限制
2. `wait`方法执行后会释放对象锁，允许其他线程获得该对象锁（我放弃，但你们还可以用）
3. 而`sleep`如果在`synchronized`代码块中执行，并不会释放对象锁（我放弃，你们也用不了）