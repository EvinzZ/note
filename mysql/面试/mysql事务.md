# mysql事务

**事务**

**简介**

事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有SQL语句均执行成功，则事务被顺利执行。

**局部性原理**

空间局部性：程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分。

时间局部性：最近访问过的程序代码和数据，很快又被访问的可能性很大。

**磁盘预读**

预读的长度一般为页(page)的整数倍。

页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4K），主存和磁盘以页为单位交换数据。

**事务的实现原理**

- 事务的原子性是通过undo log来实现的
- 事务的持久性是通过redo log来实现的
- 事务的隔离醒是通过（读写锁+MVCC）来实现的
- 事务的一致性是通过原子性，持久性，隔离性来实现的

**概念**

数据库事务是构成单一逻辑单元的操作集合

注意点：

1、数据库事务可以包含一个或多个数据库操作，但这些操作构成一个逻辑上的整体

2、构成逻辑整体的这些数据库操作，要么全部执行成功，要么全部不执行

3、构成事务的所有操作，要么全都对数据库产生影响，要么全都不产生影响，即不管事务是否执行成功，数据库总能保持一致性状态

4、并发操作下，事务的控制尤为关键

**ACID**

**原子性**

一个事务中的操作要么全部成功，要么全部失败。

**一致性**

数据库总是从一个一致性的状态切换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块钱，因为事务没有提交，修改也就不会保存到数据库。

**隔离性**

一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**持久性**

一旦事务提交，所做的修改就会永久保存到数据库中。            

**操作**

​                开启事务 set autocommit=0; // 关闭自动提交 start transaction; // 开启一个事务 ... savepoint x; // 设置保存点，用于回滚到该点，不是必须 ... commit; // 提交事务 rollback; // 回滚事务 rollback to x; // 回滚到x保存点              

在事务的四个特点中，一致性是事务的根本追求，而在某些情况下会对事务的一致性造成破坏：

- 事物的并发执行
- 事务故障或系统故障

数据库系统通过并发控制技术和日志恢复技术来避免这种情况的发生

- 并发控制技术保证了事物的隔离性，使数据库的一致性状态不会因为并发执行的操作被破坏。
- 日志恢复技术保证了事务的原子性，使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失，保证了事务的持久性。

**原子性实现原理：Undo log**

Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制（简称：MVCC）

在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

注意：undo log是逻辑日志，可以理解为：

- 当delete一条记录时，undo log中会记录一条对应的insert记录
- 当insert一条记录时，undo log中会记录一条对应的delete记录
- 当update一条记录时，它记录一条对应相反的update记录

**持久性实现原理：Redo log**

和Undo Log相反，Redo log记录的是新数据的备份。在事务提交前，只要将Redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

​                                                                  -> redo log buffer User Space ->InnoDB Engine->Log Buffer(进程内存)->{                   ->kernel Space->OS Buffer(系统内存)->磁盘                                                  -> undo log buffer               

**隔离性实现原理：锁**

在mysql中 ，锁可以分为两类：

- 共享锁：共享锁定时将对象数据变为只读形式，不能进行更新，所以也称为读取锁定；
- 排它锁：排它锁定是当执行INSERt/UPDATE/DELETE的时候，其他事务不能读取该数据，因此也称为写入锁定。

锁的粒度：锁定对象的大小是锁的粒度

- 记录
- 表
- 数据库

**故障及故障恢复**

- 撤销事务undo：将事务更新的所有数据项恢复为日志中的旧值
- 重做事务redo：将事务更新的所有数据项恢复为日志中的新值
- 事务正常回滚/因事务故障终止将进行redo
- 系统从崩溃中恢复时将先进行redo在进行undo

**MVCC**

即多版本并发控制

**MySQL日志分类**

- undo log
- redo log
- bin log
- relay log（主从复制会用到）
- slow log（慢查询日志）

undo、redo只在innodb引擎中

## 2.隔离级别

**隔离级别**

- 读未提交：其他事务未提交就可以读 。             ->脏读、幻读、不可重复读
- 读已提交：其他事务只有提交了才能读 .            ->不可重复读、幻读
- 可重复读：在事务提交前读区到的值始终为同一个，但是如果表中出现数据的增加和删除则读取的结果可能会有偏差（mysql默认）                  ->幻读
- 事务串行：在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能很差。

**脏读、幻读、不可重复读**

- 脏读：A事务读取B事务尚未提交的数据，并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据（**读取到另一个事务未提交的数据就是脏读**）

- 幻读：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了事务B提交的行。（一个事务插入数据，另一个事务虽然不能读取，但是插入同一条数据的时候是不能够插入的）(**事务B前后两次读取同一范围的数据，后一次读取的总数和前一次不一致，称为幻读**)

- 不可重复读：**事务B读取了两次资源数据，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致，这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读**（一个事务读取到另一个事务已经提交的数据）

**修改隔离级别语句**

​                set session transaction isolation level... 查看隔离级别 select @@tx_isolation;  