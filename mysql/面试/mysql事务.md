# mysql事务

**事务**

**简介**

事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有SQL语句均执行成功，则事务被顺利执行。

**局部性原理**

空间局部性：程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分。

时间局部性：最近访问过的程序代码和数据，很快又被访问的可能性很大。

**磁盘预读**

预读的长度一般为页(page)的整数倍。

页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4K），主存和磁盘以页为单位交换数据。

**事务的实现原理**

- 事务的原子性是通过undo log来实现的
- 事务的持久性是通过redo log来实现的
- 事务的隔离醒是通过（读写锁+MVCC）来实现的
- 事务的一致性是通过原子性，持久性，隔离性来实现的

**概念**

数据库事务是构成单一逻辑单元的操作集合

注意点：

1、数据库事务可以包含一个或多个数据库操作，但这些操作构成一个逻辑上的整体

2、构成逻辑整体的这些数据库操作，要么全部执行成功，要么全部不执行

3、构成事务的所有操作，要么全都对数据库产生影响，要么全都不产生影响，即不管事务是否执行成功，数据库总能保持一致性状态

4、并发操作下，事务的控制尤为关键

**ACID**

**原子性**

一个事务中的操作要么全部成功，要么全部失败。

**一致性**

数据库总是从一个一致性的状态切换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块钱，因为事务没有提交，修改也就不会保存到数据库。

**隔离性**

一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**持久性**

一旦事务提交，所做的修改就会永久保存到数据库中。            

**操作**

​                开启事务 set autocommit=0; // 关闭自动提交 start transaction; // 开启一个事务 ... savepoint x; // 设置保存点，用于回滚到该点，不是必须 ... commit; // 提交事务 rollback; // 回滚事务 rollback to x; // 回滚到x保存点              

在事务的四个特点中，一致性是事务的根本追求，而在某些情况下会对事务的一致性造成破坏：

- 事物的并发执行
- 事务故障或系统故障

数据库系统通过并发控制技术和日志恢复技术来避免这种情况的发生

- 并发控制技术保证了事物的隔离性，使数据库的一致性状态不会因为并发执行的操作被破坏。
- 日志恢复技术保证了事务的原子性，使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失，保证了事务的持久性。

**原子性实现原理：Undo log**

Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制（简称：MVCC）

在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

注意：undo log是逻辑日志，可以理解为：

- 当delete一条记录时，undo log中会记录一条对应的insert记录
- 当insert一条记录时，undo log中会记录一条对应的delete记录
- 当update一条记录时，它记录一条对应相反的update记录

**持久性实现原理：Redo log**

和Undo Log相反，Redo log记录的是新数据的备份。在事务提交前，只要将Redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

​                                                                  -> redo log buffer User Space ->InnoDB Engine->Log Buffer(进程内存)->{                   ->kernel Space->OS Buffer(系统内存)->磁盘                                                  -> undo log buffer               

**隔离性实现原理：锁**

在mysql中 ，锁可以分为两类：

- 共享锁：共享锁定时将对象数据变为只读形式，不能进行更新，所以也称为读取锁定；
- 排它锁：排它锁定是当执行INSERt/UPDATE/DELETE的时候，其他事务不能读取该数据，因此也称为写入锁定。

锁的粒度：锁定对象的大小是锁的粒度

- 记录
- 表
- 数据库

**故障及故障恢复**

- 撤销事务undo：将事务更新的所有数据项恢复为日志中的旧值
- 重做事务redo：将事务更新的所有数据项恢复为日志中的新值
- 事务正常回滚/因事务故障终止将进行redo
- 系统从崩溃中恢复时将先进行redo在进行undo

**MySQL日志分类**

- undo log
- redo log
- bin log
- relay log（主从复制会用到）
- slow log（慢查询日志）

undo、redo只在innodb引擎中

## 2.隔离级别

**隔离级别**

- 读未提交：其他事务未提交就可以读 。             ->脏读、幻读、不可重复读
- 读已提交：其他事务只有提交了才能读 .            ->不可重复读、幻读
- 可重复读：在事务提交前读取到的值始终为同一个，但是如果表中出现数据的增加和删除则读取的结果可能会有偏差（mysql默认）                  ->幻读
- 事务串行：在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能很差。

**脏读、幻读、不可重复读**

- 脏读：A事务读取B事务尚未提交的数据，并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据（**读取到另一个事务未提交的数据就是脏读**）

- 幻读：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了事务B提交的行。（一个事务插入数据，另一个事务虽然不能读取，但是插入同一条数据的时候是不能够插入的）(**事务B前后两次读取同一范围的数据，后一次读取的总数和前一次不一致，称为幻读**)

- 不可重复读：**事务B读取了两次资源数据，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致，这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读**（一个事务读取到另一个事务已经提交的数据）

**修改隔离级别语句**

```sql
set session transaction isolation level... 
// 查看隔离级别 
select @@tx_isolation;  
```

## 2.隔离级别2.0

### 2.1.隔离级别

**读未提交**

在这个隔离级别，所有事务都可以“看到”未提交事务的执行结果。在这种级别上，可能会产生很多问题，除非用户真的知道自己在做什么，并有很好的理由这样做。本隔离级别很少用于实际应用，因为它的性能也不比其他性能好多少，而别的级别还有其他更多的优点。读取未提交数据，也被称为“脏读”

**读已提交**

大多数数据库系统的默认隔离级别（但是不是MySQL的默认隔离级别），满足了隔离的早先简单定义：一个事务开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的“不可重复读”。这意味着用户运行同一个语句两次，看到的结果是不同的。

**可重复读**

MySQL默认的隔离级别，该级别解决了READ UNCOMMITTED隔离级别导致的问题。他保证同一事务的多个实例在并发读取事务时，会“看到同样的”数据行。不过这会导致另外一个棘手问题“幻读”。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。

**可串行化**

该级别是最高级别的隔离级，他通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，可串行化是在每个读的数据行上加锁。在这个级别，可能导致大量的超时Timeout和锁竞争Lock Contention现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级别。

### 2.2.隔离级别产生的问题

**脏读**

脏读是指一个事务读取了未提交事务执行过程中的数据。

当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据

**不可重复读**

不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。

不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成事务的执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。

**幻读**

幻读是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

## 3.ACID是靠什么保证的

- 原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

- 一致性是由其他三大特性保证，程序代码要保证业务上的一致性

- 隔离性由MVCC来保证
- 持久性由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存陈宫，只要日志保存成功了，数据仍然不会丢失

## 4.MVCC

多版本并发控制

### 4.1. MVCC解决的问题是什么

数据库并发场景有三种，分别为：

1. 读读：不存在任何问题，也不需要并发控制
2. 读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读
3. 写写：有线程安全问题，可能存在更新丢失问题

MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照，所以MVCC可以为数据库解决以下问题：

1. 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据并发读写的性能
2. 解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题